package org.hittepit.smapapi.mapper

import org.hittepit.smapapi.test.JdbcTestTransaction
import org.scalatest.mock.MockitoSugar
import org.scalatest.MustMatchers
import org.scalatest.WordSpec
import org.slf4j.LoggerFactory
import org.scalatest.BeforeAndAfterAll
import org.scalatest.BeforeAndAfter

class TestMapperInsertMethod extends WordSpec with MustMatchers with MockitoSugar with MockBookMapper with BeforeAndAfter with BeforeAndAfterAll{
  val logger = LoggerFactory.getLogger(classOf[TestMapperInsertMethod])

  before{
	  inTransaction{ connection =>
		  var st = connection.createStatement
		  st.addBatch("create table BOOK (id integer auto_increment,isbn varchar(10),title varchar(20),author varchar(20), price double, PRIMARY KEY(id));")
		  st.addBatch("insert into book (id,isbn,title,author,price) values (1,'12312','Test','toto',10.40);")
		  st.addBatch("insert into book (id,isbn,title,author,price) values (2,'12313','Test2',null,5.60);")
		  st.addBatch("insert into book (id,isbn,title,author,price) values (3,'12314','Test3','toto',2.25);")
		  st.executeBatch()
	  }
  }
  
  after{
    inTransaction{connection =>
		  var st = connection.createStatement
		  st.addBatch("delete from book");
	      st.addBatch("drop table BOOK;")
		  st.executeBatch()
    }
  }

  override def afterAll(){
    println("------> Closing Datasource")
    ds.close()
  }

  def invoked = afterWord("invoked")

  "The insert method" when invoked{
    "with an object with a non-defined autogenerated key" must {
      "return an instance of the same object, initialized the generated key" in withRollback{con =>
        val b = Book(None,"111","Nouveau",Some("ddd"),4.6)
        val b2 = mapper.insert(b)
        b2 must not be(null)
        b2.id.isDefined must be (true)
        b2.title must be("Nouveau")
        b2.author must be(Some("ddd"))
        b2.price must be(4.6)
      }
      
      "insert the object in database" in withRollback{con =>
        val b = Book(None,"111","Nouveau",Some("ddd"),4.6)
        val b2 = mapper.insert(b)
        val id = b2.id.get
        val st = con.prepareStatement("select * from BOOK where id = ?")
        st.setInt(1, id)
        val rs = st.executeQuery()
        rs.next()
        rs.getString("title") must be("Nouveau")
        rs.getString("author") must be("ddd")
        rs.getDouble("price") must be(4.6)
      }
      
      "insert the object in database with null where properties are None" in withRollback{con =>
        val b = Book(None,"111","Nouveau",None,4.6)
        val b2 = mapper.insert(b)
        val id = b2.id.get
        val st = con.prepareStatement("select * from BOOK where id = ?")
        st.setInt(1, id)
        val rs = st.executeQuery()
        rs.next()
        rs.getString("title") must be("Nouveau")
        rs.getString("author")
        rs.wasNull() must be(true)
        rs.getDouble("price") must be(4.6)
      }
    }
    
    "with an object initialized autogenerated key" must {
      "throw an IllegalArgumentException" in withRollback{con =>
        val b = Book(Some(50),"1414","Must fail",Some("one"),4.6)
        an [IllegalArgumentException] must be thrownBy(mapper.insert(b))
      }
    }
    
    "with an object with a key not auto-generated" must{
      "return a new version, that may be the same instance, of the object" in withRollback{con =>
        pending
      }
      "insert the object in database" in {
	      pending
      }    
    }
  }
}